# Example: Two-party tensor sum using file-based communication
# This demonstrates how to use Sequre with SyftBox file-based transport
#
# For local testing (all parties on one machine):
#   ./sequre.sh example/syftbox_sum.codon
#
# For distributed deployment (each party on different machine):
#   # Machine 1 (trusted dealer CP0):
#   SEQURE_CP_COUNT=3 sequre example/syftbox_sum.codon 0
#
#   # Machine 2 (compute party CP1):
#   SEQURE_CP_COUNT=3 sequre example/syftbox_sum.codon 1
#
#   # Machine 3 (compute party CP2):
#   SEQURE_CP_COUNT=3 sequre example/syftbox_sum.codon 2
#
# The base_dir should point to a folder that is synced between all parties
# (e.g., via SyftBox sync mechanism)

from sequre import sequre, Sharetensor as ST
from sequre.file_runtime import file_local, file_party


# Secure element-wise addition of two tensors
@sequre
def secure_tensor_add(mpc, a, b):
    return a + b


# Secure total sum of all elements
@sequre
def secure_tensor_total_sum(mpc, tensor):
    row_sums = tensor.sum(axis=0)
    return row_sums.sum(axis=0)


# Use @file_local for local testing with file-based transport
# Change the base_dir to your desired location
@file_local(base_dir="/tmp/sequre_syftbox_test", poll_interval_ms=50)
def demo(mpc):
    # Each party's private tensor input
    cp1_data = [[1, 2, 3], [4, 5, 6]]
    cp2_data = [[10, 20, 30], [40, 50, 60]]
    zero_data = [[0, 0, 0], [0, 0, 0]]

    # Secret-share each party's tensor
    a = ST.enc(mpc, cp1_data if mpc.pid == 1 else zero_data, source_pid=1, modulus=mpc.default_mpc_modulus)
    b = ST.enc(mpc, cp2_data if mpc.pid == 2 else zero_data, source_pid=2, modulus=mpc.default_mpc_modulus)

    # Secure computation
    tensor_sum = secure_tensor_add(mpc, a, b)
    total = secure_tensor_total_sum(mpc, tensor_sum)

    # Reveal results
    if mpc.pid in (1, 2):
        print(f"CP{mpc.pid}: Element-wise sum:")
        print(tensor_sum.reveal(mpc))
        print(f"CP{mpc.pid}: Total = {total.reveal(mpc)}")


# Run with file-based communication
demo()
