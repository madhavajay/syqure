import os

from internal.gc import sizeof

from sequre.constants import FILE_TRANSPORT_DIR, FILE_TRANSPORT_POLL_MS, NUMBER_OF_PARTIES

from C import access(cobj, int) -> int
from C import usleep(int) -> int
from C import unlink(str) -> int


@tuple
class FileChannel:
    local_pid: int
    remote_pid: int
    base_dir: str


channels = dict[int, FileChannel]()
send_seq = dict[int, int]()
recv_seq = dict[int, int]()

def _wait_for_ready(path: str):
    poll_us = max(1, FILE_TRANSPORT_POLL_MS) * 1000
    while access(path.c_str(), 0) != 0:
        usleep(poll_us)

def _ensure_dir(path: str):
    if access(path.c_str(), 0) == 0:
        return
    try:
        os.mkdir(path)
    except OSError:
        pass

def _channel_dir(base_dir: str, from_pid: int, to_pid: int) -> str:
    return f"{base_dir}/{from_pid}_to_{to_pid}"

def _msg_path(base_dir: str, from_pid: int, to_pid: int, seq: int) -> str:
    return f"{_channel_dir(base_dir, from_pid, to_pid)}/{seq:08d}.msg"

def _ready_path(base_dir: str, from_pid: int, to_pid: int, seq: int) -> str:
    return f"{_channel_dir(base_dir, from_pid, to_pid)}/{seq:08d}.ready"


def file_socket_id(local_pid: int, remote_pid: int) -> int:
    return -(local_pid * NUMBER_OF_PARTIES + remote_pid + 1)


def register_channel(sock_fd: int, local_pid: int, remote_pid: int, base_dir: str = FILE_TRANSPORT_DIR):
    channels[sock_fd] = FileChannel(local_pid, remote_pid, base_dir)
    if sock_fd not in send_seq:
        send_seq[sock_fd] = 0
    if sock_fd not in recv_seq:
        recv_seq[sock_fd] = 0
    _ensure_dir(base_dir)
    _ensure_dir(_channel_dir(base_dir, local_pid, remote_pid))
    _ensure_dir(_channel_dir(base_dir, remote_pid, local_pid))


def send_file(sock_fd: int, jar: Jar, msg_len: int) -> int:
    ch = channels[sock_fd]
    seq = send_seq[sock_fd]
    msg_path = _msg_path(ch.base_dir, ch.local_pid, ch.remote_pid, seq)
    ready_path = _ready_path(ch.base_dir, ch.local_pid, ch.remote_pid, seq)

    with open(msg_path, "wb") as f:
        msg_len64 = i64(msg_len)
        _C.fwrite(__ptr__(msg_len64).as_byte(), 1, sizeof(i64), f.fp)
        _C.fwrite(jar, 1, msg_len, f.fp)
        f.flush()

    with open(ready_path, "wb"):
        pass

    send_seq[sock_fd] = seq + 1
    return msg_len


def receive_file(sock_fd: int, msg_len: int) -> Jar:
    ch = channels[sock_fd]
    seq = recv_seq[sock_fd]
    msg_path = _msg_path(ch.base_dir, ch.remote_pid, ch.local_pid, seq)
    ready_path = _ready_path(ch.base_dir, ch.remote_pid, ch.local_pid, seq)

    _wait_for_ready(ready_path)

    with open(msg_path, "rb") as f:
        len_buf = ptr[byte](sizeof(i64))
        if int(_C.fread(len_buf, 1, sizeof(i64), f.fp)) != sizeof(i64):
            raise IOError("file transport: failed to read message length")
        file_len = ptr[i64](len_buf)[0]
        if file_len != msg_len:
            raise IOError(f"file transport: expected {msg_len} bytes, got {file_len}")
        data_buf = ptr[byte](file_len)
        if int(_C.fread(data_buf, 1, file_len, f.fp)) != file_len:
            raise IOError("file transport: failed to read message body")

    unlink(msg_path)
    unlink(ready_path)
    recv_seq[sock_fd] = seq + 1
    return data_buf
